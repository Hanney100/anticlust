% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anticlustering-wrapper.R
\name{anticlustering}
\alias{anticlustering}
\title{Anticlustering}
\usage{
anticlustering(features = NULL, distances = NULL, K,
  objective = "distance", method = "heuristic", preclustering = TRUE,
  standardize = FALSE, nrep = 10000)
}
\arguments{
\item{features}{A vector, matrix or data.frame of data points. Rows
correspond to elements and columns correspond to features. A
vector represents a single feature.}

\item{distances}{Alternative data argument that can be used if
\code{features} is not passed. A N x N matrix representing the
pairwise dissimilarities between all N elements. Larger values
indicate higher dissimilarity. Can be an object of class
\code{dist} (e.g., returned by \code{\link{dist}} or
\code{\link{as.dist}}) or a \code{matrix} where the entries of
the upper and/or lower triangular matrix represent the pairwise
dissimilarities.}

\item{K}{How many anticlusters should be created.}

\item{objective}{The objective to be maximized. The option
"distance" (default) is used to optimize the anticluster
editing objective; the option "variance" is used to optimize
the k-means anticlustering objective. See details.}

\item{method}{One of "heuristic" or "exact". See details.}

\item{preclustering}{Boolean, should a preclustering be conducted
before anticlusters are created. Defaults to \code{TRUE}. See
details.}

\item{standardize}{Boolean - should the features be standardized
before anticlusters are created? Defaults to \code{FALSE}.
Standardization is done using the function \code{\link{scale}}
using the default settings (mean = 0, SD = 1). This argument
only works in combination with the \code{features} argument,
not with \code{distances}.}

\item{nrep}{The number of repetitions for the random sampling
heuristic.  This argument only has an effect if \code{method}
is \code{"heuristic"}. It does not have an effect if
\code{method} is \code{"exact"}.}
}
\value{
A vector representing the anticluster affiliation.
}
\description{
Create equal sized groups of elements (anticlusters) that are as
similar as possible.
}
\details{
This function is used to solve balanced K anticlustering. That is,
K equal sized groups are created in such a way that similarity of
all groups is maximized. Set similarity is assessed using one of
two objective functions:

- k-means *variance* objective, setting \code{objective =
  "variance"}

- cluster editing *distance* objective, setting \code{objective =
  "distance"}

The k-means objective maximizes the variance within
anticlusters. The cluster editing objective maximizes the sum of
pairwise distances within anticlusters. If the argument
\code{features} is passed together with \code{objective =
"distance"}, the Euclidean distance is computed. If another measure
of dissimilarity is preferred, pass a self-computed dissimiliarity
matrix via the argument \code{distances}. Maximizing either of
these objectives is used to create similar groups; minimization of
the same objectives leads to a clustering, i.e., elements are as
similar as possible within a set and as different as possible
between sets, see \code{\link{balanced_clustering}}.

The optimal anticluster editing objective can be found via integer
linear programming; for the k-means objective, there is only a
heuristic option. Vary the parameter \code{method} to select a
"heuristic" or "exact" computation. To obtain an optimal solution
for anticluster editing, a linear programming solver must be
installed and usable from R. The `anticlust` package supports the
open source GNU linear programming kit (called from the package
\code{Rglpk}) and the commercial solvers gurobi (called from the
package \code{gurobi}) and IBM CPLEX (called from the package
\code{Rcplex}). A license is needed to use one of the commercial
solvers. The optimal solution is retrieved by setting
\code{objective = "distance"}, \code{preclustering = FALSE}, and
\code{method = "exact"}. Use this combination of arguments only for
small problem sizes (maybe <= 30 elements).

To relax the optimality condition, it is possible to set
\code{preclustering = TRUE}. In this case, the anticluster editing
objective is still optimized using integer linear programming, but a
preprocessing forbids very similar elements to be assigned to the
same anticluster. This approach can be used to work on larger problem
instances and the solution is usually still optimal or very close to
optimal.

If no exact solution is required or the problem size is too large for
integer linear programming, a heuristic method, based on repeated
random sampling, is available. Across a specified number of runs,
anticlusters are assigned randomly and the best assignment is
returned. This method works for both anticluster editing and k-means
anticlustering. The sampling approach may also incorporate a
preclustering that prevents grouping very similar elements into the
same anticluster; use \code{preclustering = TRUE} to activate this
option, which is also the default. It is suggested that the
preclustering condition is activated for the random sampling approach
because it usually improves the quality of the solution.
}
\examples{

## Use anticlustering on the iris data set with the default settings:
# (a) Optimizes the distance objective
# (b) Heuristic method: random sampling
# (c) 10,000 sampling repetitions
# (d) Preclustering is activated
# (e) Anticlustering uses standardized features (each feature has
#     mean = 0 and SD = 1)

data(iris)
# Only use numeric attributes
anticlusters <- anticlustering(iris[, -5], K = 3)
# Compare feature means by anticluster
by(iris[, -5], anticlusters, function(x) round(colMeans(x), 2))
# Plot the anticlustering
par(mfrow = c(1, 2))
plot_clusters(iris[, 1:2], anticlusters)
plot_clusters(iris[, 3:4], anticlusters)

## Exact anticlustering
# Create artifical data
n_features <- 2
n_elements <- 20
K <- 2
features <- matrix(rnorm(n_elements * n_features), ncol = n_features)
anticlustering(features, K = K, method = "exact",
               preclustering = FALSE, standardize = FALSE)

# Enable preclustering
anticlustering(features, K = K, method = "exact",
               preclustering = TRUE, standardize = FALSE)

}
\references{
Grötschel, M., & Wakabayashi, Y. (1989). A cutting plane algorithm
for a clustering problem. Mathematical Programming, 45, 59–96.

Späth, H. (1986). Anticlustering: Maximizing the variance criterion.
Control and Cybernetics, 15, 213–218.
}
