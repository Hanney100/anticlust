% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anticlustering.R
\name{anticlustering}
\alias{anticlustering}
\title{Algorithms for anticlustering}
\usage{
anticlustering(features, n_anticlusters, objective = "distance",
  method = "annealing", preclustering = TRUE, standardize = TRUE,
  nrep = 10000)
}
\arguments{
\item{features}{A vector, matrix or data.frame of data points. Rows
correspond to elements and columns correspond to features.
A vector represents a single feature.}

\item{n_anticlusters}{How many anticlusters should be created.}

\item{objective}{The objective to be maximized, either "distance"
(default) or "variance". See Details.}

\item{method}{One of "annealing", "sampling", or "exact". See details.}

\item{preclustering}{Boolean, should a preclustering be conducted
before anticlusters are created. Defaults to `TRUE`.}

\item{standardize}{Boolean - should the features be standardized
before anticlusters are created? Defaults to `TRUE`.
Standardization is done using the function \code{\link{scale}}.}

\item{nrep}{The number of repetitions used in the heuristic methods
"sampling" or "annealing".}
}
\value{
A vector representing anticluster affiliation
}
\description{
Create groups of elements (anticlusters) that are as similar as
possible.
}
\details{
TODO: Some explanation of objective.

An exact solution can only be obtained when the `objective` is
"distance". To obtain the optimal objective for the distance
criterion, use \code{preclustering = FALSE}, \code{method = "exact"}, and
\code{objective = "distance"}. Use method exact only for small problem
sizes (< 30 elements). To use the exact approach, a linear
programming solver must be installed and usable from R. The open
source GNU linear programming kit (called from the package \code{Rglpk})
or one of the commercial solvers gurobi (called from the package
\code{gurobi}) or IBM CPLEX (called from the package \code{Rcplex}) can be
used. A license is needed for the commercial solvers and one of the
interface packages must be installed.

Two heuristic approaches are available, one based on repeated random
sampling and another based on simulated annealing. Both approaches
may rely on a preclustering that prevents grouping very similar elements
into the same anticluster if we set \code{preclustering = TRUE}.
}
\examples{

# Use Iris data set with the default settings
data(iris)
anticlusters <- anticlustering(iris[, -5], n_anticlusters = 3)
# Compare feature means by anticluster
by(iris[, -5], anticlusters, colMeans)
# Plot the anticlustering
par(mfrow = c(1, 2))
plot_clusters(iris[, 1:2], anticlusters) # see overlap
plot_clusters(iris[, 3:4], anticlusters)


}
\references{
M. Grötschel and Y. Wakabayashi, “A cutting plane algorithm for a
clustering problem,” Mathematical Programming, vol. 45, nos. 1-3, pp.
59–96, 1989.

H. Späth, “Anticlustering: Maximizing the variance criterion,”
Control and Cybernetics, vol. 15, no. 2, pp. 213-218, 1986.
}
