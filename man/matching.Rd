% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching-wrapper.R
\name{matching}
\alias{matching}
\title{Matching}
\usage{
matching(
  features = NULL,
  distances = NULL,
  p = 2,
  groups = NULL,
  match_extreme_first = NULL
)
}
\arguments{
\item{features}{A numeric vector, matrix or data.frame of data
points.  Rows correspond to elements and columns correspond to
features. A vector represents a single numeric feature.}

\item{distances}{Alternative data argument that can be used if
\code{features} is not passed. An N x N matrix representing the
pairwise dissimilarities between N elements. Larger values
indicate higher dissimilarity. Can be an object of class
\code{dist} (e.g., returned by \code{\link{dist}} or
\code{\link{as.dist}}) or a \code{matrix} where the entries of
the upper and lower triangular matrix represent the pairwise
dissimilarities.}

\item{p}{The size of the groups; the default is 2, in which case
the function returns pairs.}

\item{groups}{An optional categorical vector inducing grouping
restrictions. If passed, the argument \code{p} is ignored and
matches are sought between elements of different groups.}

\item{match_extreme_first}{Logical: Determines if matches are
sought for extreme elements first or for central elements. If
not specified, is determined on the basis of the other
arguments (see Details).}
}
\value{
An integer vector encoding the matches. See Setails for
    more information.
}
\description{
Conduct K-partite or unrestricted (minimum distance) matching to
find pairs or groups of similar elements. By default, finding
matches is based on the Euclidean distance between data points, but
a custom distance measure can also be employed.
}
\details{
If the argument \code{features} is passed, matching is done based
on the Euclidean distance between data points. If the argument
\code{distances} is passed, this matrix serves to define
dissimilarity between data points. To find matches, the algorithm
proceeds by selecting a target element and then searching its
nearest neighbours. Critical to the behaviour or the algorithm is
the order in which target elements are selected. In most cases the
most extreme elements are selected first, i.e., elements with the
highest distance to the center of the data set (see
\code{\link{balanced_clustering}}). By setting the argument
\code{match_extreme_first} to \code{FALSE}, it is possible to
enforce that elements close to the center are first selected as
targets. By default, this only happens for unrestricted matching
(that is, if the argument \code{groups} is not specified) if the
data set cannot be evenly divided into groups of size \code{p}. In
all other cases, \code{match_extreme_first} is set to \code{TRUE}
by default. If the argument \code{groups} is passed and the groups
are of different size, the target elements is always selected from
the smallest group (because in this group, all elements can be
matched).

The output is an integer vector encoding which elements have been
matched. The grouping numbers are sorted by similarity. That is,
elements with the grouping number »1« are most similar to each
other, followed by 2 etc (groups having the same similarity index
are still assigned a different grouping number, though). Similarity
is measured as the sum of pairwise (Euclidean) distances within
groups \code{\link{distance_objective}}.  Some elements of the
output may be \code{NA}. This happens if it is not possible to
evenly split the item pool evenly into groups of size \code{p} or
if the categories described by the argument \code{groups} are of
different size. Unmatched items are then assigned \code{NA}.
}
\examples{

# Find triplets
N <- 29 # two elements will not be matched
lds <- data.frame(f1 = rnorm(N), f2 = rnorm(N))
triplets <- matching(lds, p = 3)
table(triplets)
sum(is.na(triplets))
plot_clusters(
  lds,
  clustering = triplets,
  within_connection = TRUE
)

# Bipartite matching with unequal-sized groups: Only selects matches for some elements
N <- 100
data <- matrix(rnorm(N), ncol = 1)
groups <- sample(1:2, size = N, replace = TRUE, prob = c(0.7, 0.3))
matched <- matching(data[, 1], groups = groups)
plot_clusters(
  cbind(groups, data), 
  clustering = matched, 
  within_connection = TRUE
)

# Match between different plant species in the »iris« data set
species <- iris$Species != "versicolor"
matched <- matching(
  iris[species, 1], 
  groups = iris[species, 5]
)
# Adjust `match_extreme_first` argument
matched2 <- matching(
  iris[species, 1], 
  groups = iris[species, 5],
  match_extreme_first = FALSE
)
# Plot the matching results
par(mfrow = c(1, 2))
data <- data.frame(
  Species = as.numeric(iris[species, 5]),
  Sepal.Length = iris[species, 1]
)
plot_clusters(
  data,
  clustering = matched,
  within_connection = TRUE,
  main = "Extreme elements matched first"
)
plot_clusters(
  data,
  clustering = matched2,
  within_connection = TRUE,
  main = "Central elements matched first"
)
par(mfrow = c(1, 1))


}
\author{
Martin Papenberg \email{martin.papenberg@hhu.de}
}
