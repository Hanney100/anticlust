% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fast_anticlustering.R
\name{fast_anticlustering}
\alias{fast_anticlustering}
\title{Fast anticlustering}
\usage{
fast_anticlustering(
  x,
  K,
  k_neighbours = Inf,
  categories = NULL,
  exchange_partners = NULL,
  backend = "C"
)
}
\arguments{
\item{x}{A numeric vector, matrix or data.frame of data points.
Rows correspond to elements and columns correspond to
features. A vector represents a single numeric feature.}

\item{K}{How many anticlusters should be created. Alternatively:
(a) A vector describing the size of each group, or (b) a vector
of length \code{nrow(x)} describing how elements are assigned
to anticlusters before the optimization starts.}

\item{k_neighbours}{The number of neighbours that serve as exchange
partner for each element. Defaults to \code{Inf}, implying that
each element is exchanged with each element in other groups.}

\item{categories}{A vector, data.frame or matrix representing one
or several categorical constraints.}

\item{exchange_partners}{Optional argument. A list of length
\code{NROW(x)} specifying for each element the indices of the
elements that serve as exchange partners. If used, this
argument overrides the \code{k_neighbours} argument. See
examples.}

\item{backend}{Either "C" or "R", to use a C or R implementation of
the anticlustering optimization algorithm. Since
\code{anticlust} version 0.7.1, the faster C implementation is
the default.}
}
\description{
Increasing the speed of (k-means / k-plus) anticlustering by
conducting fewer exchanges during the optimization. This function
uses an adjusted exchange method in which the number of exchange
partners can be specified. Using fewer exchange partners can make
anticlustering applicable to quite large data sets.
}
\details{
This function was created to make anticlustering applicable to
large data sets (e.g., several 100,000 elements). It optimizes the
k-means objective because computing all pairwise distances as is
done when optimizing the "diversity" (i.e., the default in
\code{\link{anticlustering}}) is not feasible for very large data
sets (for about N > 20000 on my personal computer). Extending
\code{fast_anticlustering} to k-plus anticlustering is rather straight
forward by applying \code{\link{kplus_moment_variables}} on the input (see
examples).

The function \code{fast_anticlustering} employs a speed-optimized
exchange method, which is basically equivalent to \code{method =
"exchange"} in \code{\link{anticlustering}}, but (possibly) reduces
the number of exchanges that are investigated for each input
element. For each element, the potential exchange partners are
generated using a nearest neighbour search with the function
\code{\link[RANN]{nn2}} from the \code{RANN} package. Only the
nearest neighbours then serve as exchange partners. The number of
exchange partners per element has to be set using the argument
\code{k_neighbours}; by default, it is set to \code{Inf}, meaning
that all possible swaps are tested. This default must be changed by
the user for large data sets. If the default is not changed, you
can also just use the function \code{\link{anticlustering}}. More
exchange partners generally improve the quality of the results, but
also increase run time. Note that for very large data sets,
anticlustering generally becomes "easier" (even a random split may
yield satisfactory results), so using few exchange partners is
usually not a problem.

For a fixed number of exchange partners (specified using the
argument \code{k_neighbours}) the approximate run time of
\code{fast_anticlustering} is in O(M N^2), where N is the total
number of elements and M is the number of variables. The algorithm
\code{method = "exchange"} in \code{\link{anticlustering}} has a
run time of O(M N^3) because for each element, all other elements
serve as exchange partners. Thus, \code{fast_anticlustering} can
improve the run time by an order of magnitude as compared to the
standard exchange algorithm. The nearest neighbour search, which is
done in the beginning, only has O(N log(N)) run time and therefore
does not strongly contribute to the overall run time. It is
possible to suppress the nearest neighbour search by passing custom
exchange partners using the \code{exchange_partners} argument. When using
\code{exchange_partners}, it is not necessary that each element has
the same number of exchange partners (this is why the argument
\code{exchange_partners} has to be a list instead of matrix / data
frame). Exchange partners can for example be generated by 
\code{\link{generate_exchange_partners}} (see examples), but a custom 
list may also be used. 

When setting the \code{categories} argument, exchange partners
(i.e., nearest neighbours) will be generated from the same
category. Note that when \code{categories} has multiple columns
(i.e., each element is assigned to multiple columns), each
combination of categories is treated as a distinct category by the
exchange method. You can also use
\code{\link{categories_to_binary}} to improve results for several
categorical variables, instead of using the argument
\code{categories}.
}
\examples{

features <- iris[, - 5]

ac_exchange <- fast_anticlustering(features, K = 3)

## The following call is (quasi) equivalent to the call above:
ac_exchange <- anticlustering(features, K = 3, objective = "variance")

## Improve run time by using fewer exchange partners:
ac_fast <- fast_anticlustering(features, K = 3, k_neighbours = 10)

# Applying k-plus anticlustering with this function is straight forward,
# just use kplus_moment_variables() on the numeric input:
kplus_anticlusters <- fast_anticlustering(kplus_moment_variables(features, T = 2), K = 3)
mean_sd_tab(features, kplus_anticlusters) # Means and SDs are similar

# Working on several 1000 elements is very fast (Here n = 5000)
data <- matrix(rnorm(5000 * 2), ncol = 2)
groups <- fast_anticlustering(data, K = 2, k_neighbours = 2)
mean_sd_tab(data, groups)

# Use custom exchange partners, here: 10 random exchange partners for each element
features <- matrix(rnorm(500 * 5), ncol = 5)
n_exchange_partners <- 10
K <- 100
init <- sample(rep_len(1:K, nrow(features)))
groups_rnd_partners <- fast_anticlustering(
  features, 
  K = init, 
  exchange_partners = generate_exchange_partners(
    n_exchange_partners, 
    features = features, method = "random"
  )
)

# compare with using nearest neighbours as exchange partners (i.e., the default)
groups_nn_partners <- fast_anticlustering(features, K = init, k_neighbours = n_exchange_partners)
groups_all_partners <- fast_anticlustering(features, K = init)

variance_objective(features, groups_nn_partners)
variance_objective(features, groups_rnd_partners)
variance_objective(features, groups_all_partners)

}
\references{
Papenberg, M., & Klau, G. W. (2021). Using anticlustering to partition 
data sets into equivalent parts. Psychological Methods, 26(2), 
161â€“174. https://doi.org/10.1037/met0000301.

Papenberg, M. (2023). K-plus Anticlustering: An Improved k-means Criterion 
for Maximizing Between-Group Similarity. British Journal of Mathematical 
and Statistical Psychology. Advance online publication. 
https://doi.org/10.1111/bmsp.12315
}
\seealso{
\code{\link{anticlustering}}

\code{\link{kplus_moment_variables}}

\code{\link{categories_to_binary}}

\code{\link{variance_objective}}

\code{\link{generate_exchange_partners}}
}
\author{
Martin Papenberg \email{martin.papenberg@hhu.de}
}
