
#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{sort_by_group}, contains features or distances and
#'     information on grouping restrictions (as the first
#'     column, see \code{sort_by_group}).
#' @param n_anticlusters How many anticlusters should be created.
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param sampling_plan A string encoding how the anticlusters should be
#'     sampled. Is either "unrestricted" (anticlusters are simply
#'     shuffled), "preclustering" (preclustered elements are assigned
#'     to different groups) or "categorical" (the categorical variable
#'     is balanced out between anticlusters).
#' @param use_distances A boolean flag indicating whether `dat` contains
#'     distances or features. (TRUE = distances were passed)
#'
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(dat, K, objective, nrep, sampling_plan,
                            use_distances) {

  N <- nrow(dat)
  n_preclusters <- N / K
  anticlusters <- rep_len(1:K, N) # initialization for unrestricted sampling
  categories <- dat[, 1]

  ## - Determine how the objective has to be computed
  if (objective == "distance" && use_distances == TRUE) {
    obj_value <- distance_objective_
  } else if (objective == "distance" && use_distances == FALSE) {
    obj_value <- obj_value_distance
  } else {
    obj_value <- variance_objective_
  }


  ## 1. Generate random anticlusters
  ncores <- parallel::detectCores() - 1
  cl <- parallel::makeCluster(ncores)
  clusterEvalQ(cl, library("anticlust"))

  if (sampling_plan == "unrestricted") {
    assignments <- parallel::parLapply(
      1:nrep,
      fun = unrestricted_sampling,
      cl = cl,
      anticlusters = anticlusters
    )
  } else if (sampling_plan == "preclustering") {
    assignments <- parallel::parLapply(
      1:nrep,
      fun = replicate_sample,
      cl = cl,
      times = n_preclusters,
      N = K
    )
  } else if (sampling_plan == "categorical") {
    assignments <- parallel::parLapply(
      1:nrep,
      fun = categorical_sampling,
      cl = cl,
      categories = categories,
      K = K
    )
  }

  ## 2. Compute objective value for each assignment
  objectives <- parallel::parLapply(
    assignments,
    fun = obj_value,
    cl = cl,
    data = dat[, -(1:2), drop = FALSE]
  )
  parallel::stopCluster(cl)


  ## 3. Return the best assignment
  best_obj <- which.max(objectives)
  assignments[[best_obj]]
}

#' A wrapper for sample
#'
#' This function is called from \code{random_sampling}
#'
#' @param x An unused argument to make this function usable by lapply
#' @param anticlusters An anticluster assignment
#'
#' @return A shuffled permutation of \code{anticlusters}
#'
#' @noRd
unrestricted_sampling <- function(x, anticlusters) {
  sample(anticlusters)
}

#' Random sampling employing a categorical constraint
#'
#' @param x An unused argument to make this function usable by lapply
#' @param categories A vector of categories
#' @param K The number of anticlusters
#'
#' @return A random shuffling of the anticlusters that balances out
#'     the categories between samples
#'
#' @noRd

categorical_sampling <- function(x, categories, K) {
  init <- by(rep_len(1:K, length(categories)), categories, sample)
  unlist(init)
}

#' Replicate a random permutation of \code{1:N} several times
#'
#' @param x An unused argument to make this function usable by lapply
#' @param times How many times should the random sample be generated
#' @param N The function returns several random permutations of
#'     \code{1:N}
#'
#' @return \code{times} random samples of \code{1:N} in a single vector
#'
#' @examples
#' replicate_sample(3, 3)
#'
#' @noRd

replicate_sample <- function(x, times, N) {
  c(replicate(times, sample(N)))
}

