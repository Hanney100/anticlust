
#' Simple branch and bound approach to anticlustering
#'
#' @param features A vector, matrix or data.frame of data points. Rows
#'     correspond to elements and columns correspond to features. A
#'     vector represents a single feature.
#' @param K How many anticlusters should be created.
#'
#' @return A list containing the objective and the anticluster
#'     affiliations.
#'
#' @export
#'


bnb_anticlustering <- function(features, K) {

  ## Some "global" variables are necessary
  # - tree - The problem tree (a list as a first try)
  # - `distances` - the distances between all elements
  # - `minmax` - The current minimum maximum
  # - n_problems- the length of `tree`
  # - anticluster - the current best anticluster affiliations
  # - K the number of anticlusters to be created
  # - N the total number of elements
  # - temporily: candidates - a list containing all generated candidates
  # - anticlusters - the current best partitioning
  # - dist_sorted - distances matrix where each column is an item,
  #   and rows encode the distance by proximity to other elements
  #   (first row has the closest element etc)
  # - dist_sorted2 - as `dist_sorted`, but the cells do not contain
  #   distances, but elements

  features <- as.matrix(features)
  ## initialize minimum maximum via heuristic
  anticlusters <- anticlustering(features, K, method = "sampling", nrep = 50)
  minmax <- get_objective(features, anticlusters, "distance")
  distances <- as.matrix(dist(features))
  dist_sorted <- distance_structure(distances)
  tree <- new.queue()
  N <- nrow(features)

  # Compute objective for the current BnB subproblem
  #
  # @param problem, will always be the result of `dequeue(tree)`
  #
  # @return The objective value given all elements in the candidate solution
  #
  compute_bnb_objective <- function(problem) {
    ## Select all elements within the same cluster as the newly added element
    ## (most recent element, i.e., element at last position in `problem$clusters`
    anticlusters <- problem$clusters
    current_element <- length(anticlusters)
    current_cluster <- anticlusters[current_element]
    other_elements <- setdiff(which(anticlusters == current_cluster), current_element)
    ## Get all connections of current element.
    connections <- expand.grid(other_elements, current_element)
    ## Get all distances between current element and elements of the same anticluster
    distances_of_connections <- distances[as.matrix(connections)]
    ## Add sum of new distances to previous objective
    objective <- problem$prev_value + sum(distances_of_connections)
    return(objective)
  }

  ## Function that computes the maximum possible sum that can be
  ## generated by the remaining elements that are not yet part
  ## of the solution candidate (the total best objective adds the
  ## objective so far to the return value)
  best_possible_remaining <- function(length_of_candidate) {
    remaining_elements <- (length_of_candidate + 1):N
    sum(dist_sorted[1:(N / K - 1), remaining_elements])
  }

  # Process a subproblem:
  #
  # - compute objective
  # - decide if objective still good enough
  # - add split into new subproblems if appropriate

  process_problem <- function(problem) {
    objective <- compute_bnb_objective(problem)
    ## replace current minmax by objective if it is better
    if (objective > minmax) {
      minmax <<- objective
      anticlusters <<- problem$clusters
    }

    ## If all elements are part of the problem, nothing else needs to be done:
    length_of_candidate <- length(problem$clusters)
    if (!(length_of_candidate < N)) {
      return(NULL)
    }

    best_possible <- best_possible_remaining(length_of_candidate) + objective
    ## is best possible value worse than the minimum maximum to be expected?
    if (!(best_possible > minmax)) {
      return(NULL)
    }

    ## Enqueue subproblems if conditions for enqueuing are satisfied
    for (k in 1:K) {
      ## 1) Check that each cluster occurs legally often in new candidate
      ## 2) Check that the new candidate is not a redundant partition
      ## (this means that k cannot be larger than the length of the new
      ## candidate!)
      ## Only append new subproblem if both conditions are satisfied
      new_clusters <- c(problem$clusters, k)
      if (sum(new_clusters == k) <= N / K &&
          k <= length_of_candidate + 1) {
        ## new problem gets as "previous objective" the current objective
        enqueue(tree, list(clusters = new_clusters, prev_value = objective))
      }
    }
  }

  ## Add first subproblem; first element must be in anticluster 1
  ## (Why? -> See my work on partition enumeration;
  ## if the first anticluster were > 1, I would obtain redundant partitions)
  enqueue(tree, list(clusters = 1, prev_value = 0))

  ## Get all together
  while (!is.empty(tree)) {
    # takes uppermost candidate
    problem <- dequeue(tree)
    process_problem(problem)
  }

  return(list(anticlusters = anticlusters, objective = minmax))
}


## Define a queue in R using environments
## (source: https://www.researchgate.net/post/What_is_the_queue_data_structure_in_R)

new.queue <- function() {
  ret <- new.env()
  ret$front <- new.env()
  ret$front$q <- NULL
  ret$front$prev <- NULL
  ret$last <- ret$front
  return(ret)
}
## add to end of queue
enqueue <- function(queue, add){
  queue$last$q <- new.env()
  queue$last$q$prev <- queue$last
  queue$last <- queue$last$q
  queue$last$val <- add
  queue$last$q <- NULL
}
## return front of queue and remove it
dequeue <- function(queue){
  if (is.empty(queue)) {
    stop("Attempting to take element from empty queue")
  }
  value <- queue$front$q$val
  queue$front <- queue$front$q
  queue$front$q$prev <- NULL
  return(value)
}
is.empty <- function(queue){
  return(is.null(queue$front$q))
}


#' Encode the closest neighbours for each element in a matrix
#'
#' @param distances A distance matrix (computed via `as.matrix(dist(...))`)
#'
#' @return A matrix where each column is an element. The first row is the
#'     distance to the closest element, the second row the distance to the
#'     second closest element etc.
#'
#' @noRd

distance_structure <- function(distances, distance_output = TRUE) {
  N <- nrow(distances)
  output <- ifelse(distance_output == TRUE, 1, 2)
  results <- matrix(ncol = N, nrow = N)
  for (i in 1:ncol(results)) {
    ## make a data.frame from current distances and elements
    tmp_frame <- cbind(distances[i, ], 1:N)
    results[, i] <- sort_by_col(tmp_frame, 1, decreasing = TRUE)[, output]
  }
  results[-N, ]
}
