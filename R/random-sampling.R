
#' Heuristic anticlustering using random sampling
#'
#' @param data The data that is optimized on (N x M feature matrix
#'     or N x N distance matrix)
#' @param K How many anticlusters should be created.
#' @param obj_function An objective function where the first argument
#'     is a cluster assignment and the second argument is the data set.
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param categories A vector that represents categorical constraints
#'     (may be preclustering constraints).
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(data, K, obj_function, nrep, categories) {

  ## Determine objective function to be used
  sampling_plan <- get_sampling_plan(categories)

  ## Sort data by constraint-inducing variable
  dat <- sort_by_group(data, categories)

  best_assignment <- random_sampling_(
    dat,
    K,
    nrep,
    sampling_plan,
    obj_function
  )

  ## Return anticluster assignment in original order
  dat[, 1] <- best_assignment
  dat <- sort_by_col(dat, 2)
  anticlusters <- dat[, 1]
  names(anticlusters) <- NULL
  anticlusters
}

# Extracted from the above function for readability
get_sampling_plan <- function(categories) {
  ## Determine plan for random sampling
  sampling_plan <- "unrestricted"
  if (argument_exists(categories)) {
    sampling_plan <- "categorical"
  }
  sampling_plan
}


#' Sort data by a grouping variable
#'
#' @param data A data matrix representing features or distances.
#' @param group A grouping variable. A vector that represents
#'     categorical constraints. Can be NULL, see Details.
#'
#' @return An extended data matrix. The first column indicates the
#'     group category of each element (precluster or categorical variable).
#'     The matrix is sorted by the group, i.e. by the first column.
#'     The second column is a unique number identifying the original
#'     position of each element. This column is used in
#'     \code{random_sampling} to restore the original order of
#'     the data. The other columns represent the original data inpute that
#'     was passed to this function.
#'
#'  @details
#'
#'  This function sorts the input table by precluster affiliation
#'  or by a categorical variable; both restrictions are realized via the
#'  argument categories. The argument may be NULL. If that is so (i.e., no
#'  grouping restrictions are passed) the data is not sorted.
#'
#' @noRd
#'

sort_by_group <- function(data, group) {
  sort_by <- 1 # default: data does not need to be sorted
  if (argument_exists(group)) {
    sort_by <- group
  }
  dat <- cbind(sort_by, 1:nrow(data), data)
  dat <- sort_by_col(dat, 1)
  return(dat)
}

#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{sort_data}, contains features or distances and
#'     information on grouping restrictions (as the first
#'     column, see \code{sort_by_group}).
#' @param K How many anticlusters should be created.
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param sampling_plan A string encoding how the anticlusters should be
#'     sampled. Is either "unrestricted" (anticlusters are simply
#'     shuffled), "preclustering" (preclustered elements are assigned
#'     to different groups) or "categorical" (the categorical variable
#'     is balanced out between anticlusters).
#' @param use_distances A boolean flag indicating whether `dat` contains
#'     distances or features. (TRUE = distances were passed)
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling_ <- function(dat, K, nrep, sampling_plan,
                             obj_function) {

  N <- nrow(dat)
  ## Start optimizing
  best_obj <- -Inf

  ## Select the relevant data from which the objective is computed
  objective_data <- dat[, -(1:2), drop = FALSE]
  anticlusters <- rep_len(1:K, N) # initialization for unrestricted sampling
  categories <- dat[, 1]
  for (i in 1:nrep) {
    if (sampling_plan == "unrestricted") {
      anticlusters <- sample(anticlusters)
    } else {
      anticlusters <- categorical_sampling(categories, K)
    }
    cur_obj <- obj_function(anticlusters, objective_data)
    if (cur_obj > best_obj) {
      best_assignment <- anticlusters
      best_obj <- cur_obj
    }
  }
  return(best_assignment)
}

#' Random sampling employing a categorical constraint
#'
#' @param categories A vector of categories
#' @param K The number of anticlusters
#'
#' @return A random shuffling of the anticlusters that balances out
#'     the categories between samples
#'
#' @noRd

categorical_sampling <- function(categories, K) {
  init <- by(rep_len(1:K, length(categories)), categories, sample_)
  unlist(init)
}

# sample function must be redefined for categorical sampling just in case
# there is a category with only 1 member
sample_ <- function(x, ...) {
  if (length(x) == 1) {
    return(x)
  }
  sample(x, ...)
}
