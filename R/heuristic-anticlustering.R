
#' Heuristic anticlustering using random search methods
#'
#' @param features A data.frame, matrix or vector representing the
#'     features that are used.
#' @param n_anticlusters How many anticlusters should be created.
#' @param preclusters An optional vector representing the preclustering
#'     of the elements in \code{features}
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

heuristic_anticlustering <- function(features, n_anticlusters,
                                     preclusters = NULL, objective,
                                     nrep) {

  ignore_preclusters <- FALSE
  if (!argument_exists(preclusters)) {
    ignore_preclusters <- TRUE
  }

  ## Bring data into adequate format
  dat <- preclustering_data_format(features, preclusters, n_anticlusters)
  ## Call random sampling subroutine
  best_assignment <- random_sampling(dat, n_anticlusters, objective,
                                     nrep, ignore_preclusters)

  ## Return anticluster assignment in original order
  dat[, 1] <- best_assignment
  dat <- sort_by_col(dat, 2)
  anticlusters <- dat[, 1]
  names(anticlusters) <- NULL
  return(anticlusters)
}

#' Bring features into the data format required by preclustering
#' heuristic
#'
#' @param features A data.frame, matrix or vector representing the
#'     features that are used.
#' @param preclusters A vector of precluster affiliations. Can be NULL,
#'     see Details.
#'
#' @return An extended data matrix. The first column indicates the
#'     precluster for each element. The matrix is sorted by the
#'     precluster, i.e. by the first column. The second column is a
#'     unique number identifying the original position of each
#'     element. The second column is used in
#'     \code{heuristic_anticlustering} to restore the original order of
#'     the data. The other columns represent the original features that
#'     were passed to this function.
#'
#'  @details
#'
#'  If the argument \code{preclusters} is NULL, no preclustering
#'  constraint was required. This function will still add a column
#'  preclusters, which however will not have an effect on the following
#'  computations: The method \code{random_sampling} will ignore the
#'  precluster column through an
#'  argument \code{ignore_preclusters} that \code{TRUE} whenever the
#'  argument \code{preclusters} is NULL.
#'
#' @noRd
#'

preclustering_data_format <- function(features, preclusters, n_anticlusters) {
  if (!argument_exists(preclusters)) {
    ## This is actually irrelevant numbers and is ignored later on
    preclusters <- rep(1:n_anticlusters, nrow(features) / n_anticlusters)
  }
  dat <- cbind(preclusters, 1:nrow(features), features)
  dat <- sort_by_col(dat, 1) # sort by precluster
  return(dat)
}


#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{preclustering_data_format}, contains the features as well
#'     as information on preclustering restrictions (as the first
#'     column, see \code{preclustering_data_format}).
#' @param n_anticlusters How many anticlusters should be created.
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param ignore_preclusters Boolean, should the precluster information
#'     given in the first column of \code{dat} be ignored? If FALSE,
#'     elements from the same precluster are not assigned to the same
#'     anticluster.
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(dat, n_anticlusters, objective,
                            nrep, ignore_preclusters) {

  if (objective == "distance") {
    obj_value <- obj_value_distance
  } else {
    obj_value <- obj_value_variance
  }

  ## Initialize variables
  n_elements <- nrow(dat)
  n_preclusters <- n_elements / n_anticlusters
  ## Start optimizing
  best_obj <- -Inf
  # only select features so it is not done each iteration
  features <- dat[, -(1:2), drop = FALSE]
  for (i in 1:nrep) {
    ## 1. Random sampling without preclustering restrictions
    if (ignore_preclusters == TRUE) {
      anticlusters <- rep(1:n_anticlusters, n_preclusters)
      anticlusters <- sample(anticlusters)
      ## 2. Include preclustering restrictions
    } else if (ignore_preclusters == FALSE) {
      anticlusters <- replicate_sample(n_preclusters, n_anticlusters)
    }
    cur_obj <- obj_value(features, anticlusters)
    if (cur_obj > best_obj) {
      best_assignment <- anticlusters
      best_obj <- cur_obj
    }
  }
  return(best_assignment)
}

#' Replicate a random permutation of \code{1:N} several times
#'
#' @param times How many times should the random sample be generated
#' @param N The function returns several random permutations of
#'     \code{1:N}
#'
#' @return \code{times} random samples of \code{1:N} in a single vector
#'
#' @examples
#' replicate_sample(3, 3)
#'
#' @noRd
replicate_sample <- function(times, N) {
  c(replicate(times, sample(N)))
}

