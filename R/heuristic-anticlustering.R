
#' Heuristic anticlustering using random search methods
#'
#' @param features A data.frame, matrix or vector representing the
#'     features that are used.
#' @param n_anticlusters How many anticlusters should be created.
#' @param preclusters An optional vector representing the preclustering
#'     of the elements in \code{features}
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param method The method used to find the best objective. Can be
#'     "sampling" for repeated random sampling or "annealing" for
#'     simulated annealing.
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

heuristic_anticlustering <- function(features, n_anticlusters,
                                     preclusters = NULL, objective,
                                     method, nrep) {

  ignore_preclusters <- FALSE
  if (!argument_exists(preclusters)) {
    ignore_preclusters <- TRUE
  }

  ## Bring data into adequate format
  dat <- preclustering_data_format(features, preclusters, n_anticlusters)

  if (method == "sampling") {
    best_assignment <- random_sampling(dat, n_anticlusters, objective, 
                                       nrep, ignore_preclusters)
  }
  else if (method == "annealing") {
    best_assignment <- simulated_annealing(dat, n_anticlusters, objective, 
                                           nrep, ignore_preclusters)
  }

  ## Return anticluster assignment in original order
  dat[, 1] <- best_assignment
  dat <- sort_by_col(dat, 2)
  anticlusters <- dat[, 1]
  names(anticlusters) <- NULL
  return(anticlusters)
}

#' Bring features into the data format required by preclustering
#' heuristic
#'
#' @param features A data.frame, matrix or vector representing the
#'     features that are used.
#' @param preclusters A vector of precluster affiliations. Can be NULL,
#'     see Details.
#'
#' @return An extended data matrix. The first column indicates the
#'     precluster for each element. The matrix is sorted by the
#'     precluster, i.e. by the first column. The second column is a
#'     unique number identifying the original position of each
#'     element. The second column is used in
#'     \code{heuristic_anticlustering} to restore the original order of
#'     the data. The other columns represent the original features that
#'     were passed to this function.
#'
#'  @details
#'
#'  If the argument \code{preclusters} is NULL, no preclustering
#'  constraint was required. This function will still add a column
#'  preclusters, which however will not have an effect on the following
#'  computations: The methods \code{simulated_annealing} and
#'  \code{random_sampling} will ignore the precluster column through an
#'  argument \code{ignore_preclusters} that \code{TRUE} whenever the
#'  argument \code{preclusters} is NULL.
#'
#' @noRd
#'

preclustering_data_format <- function(features, preclusters, n_anticlusters) {
  if (!argument_exists(preclusters)) {
    ## This is actually irrelevant numbers and is ignored later on
    preclusters <- rep(1:n_anticlusters, nrow(features) / n_anticlusters)
  }
  dat <- cbind(preclusters, 1:nrow(features), features)
  dat <- sort_by_col(dat, 1) # sort by precluster
  return(dat)
}


#' Simulated annealing for anticlustering
#'
#' The \code{next_candidate} function below is of high relevance to the
#' simulated annealing approach.
#'
#' @param dat The data input generated by the internal function
#'     \code{preclustering_data_format}, contains the features as well
#'     as information on preclustering restrictions (as the first
#'     column, see \code{preclustering_data_format}).
#' @param n_anticlusters How many anticlusters should be created.
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param ignore_preclusters Boolean, should the precluster information
#'     given in the first column of \code{dat} be ignored?
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

simulated_annealing <- function(dat, n_anticlusters, objective,
                                nrep, ignore_preclusters) {
  ## Initialize variables
  n_elements <- nrow(dat)
  n_preclusters <- n_elements / n_anticlusters
  ## Initial parameter values; the preclustering ensures a good initial
  ## state for the simulated annealing approach. Uses a random initial
  ## state when preclustering is not considered.
  if (ignore_preclusters == TRUE) {
    init <- rep(1:n_anticlusters, n_preclusters)
    init <- sample(init)
  } else if (ignore_preclusters == FALSE) {
    init <- replicate_sample(n_preclusters, n_anticlusters)
  }

  ## Wrap objective function so it only takes the anticluster
  ## affiliation as parameter (data is included from outside the
  ## function) (the argument `ignore_preclusters` is necessary here
  ## because the `next_candidate` function has this argument and both
  ## functions must have same signature)
  objective_fun <- function(clusters, ignore_preclusters) {
    return(get_objective(dat[, -c(1, 2)], clusters, objective))
  }

  ## Use `optim` for simulated annealing
  return(optim(init, objective_fun, next_candidate, method = "SANN",
               ignore_preclusters = ignore_preclusters,
               control = list(maxit = nrep, temp = 2000, REPORT = 500,
                              fnscale = -1, tmax = 20))$par)
}


#' Generate a candidate move for simulated annealing anticlustering
#'
#' @param anticlusters The current anticluster affiliation of all
#'     elements. The anticlusters are sorted by a precluster.
#'
#' @param ignore_preclusters Boolean, should the preclustering
#'     be ignored?
#'
#' @return The anticlustering vector after swapping two elements.  See
#'     details.
#'
#'
#' The function generates one of two possible "candidate moves" (i.e.,
#' switching the anticluster affiliation of two elements), that are
#' chosen in dependence of the argument \code{ignore_preclusters}. When
#' the preclustering information is ignored, this function switches the
#' anticlusters of two random elements. When preclustering is not
#' ignored, two elements that are not part of the same anticluster are
#' switched. Both methods prevent that elements within the same anticluster
#' are switched.
#'
#' @noRd
#'

next_candidate <- function(anticlusters, ignore_preclusters) {
  if (ignore_preclusters == TRUE) {
    return(random_move(anticlusters))
  }
  return(preclustering_move(anticlusters))
}

#' Randomly exchange the anticlusters of two elements in simulated
#' annealing
#'
#' @param anticlusters The current anticluster affiliation of all
#'     elements.
#'
#' @return The anticlustering vector after swapping two elements.
#'
#' @noRd
#'

random_move <- function(anticlusters) {
  N <- length(anticlusters)
  changepoints <- sample(N, size = 2, replace = FALSE)
  # Ensure that different anticlusters are switched:
  while (anticlusters[changepoints[1]] == anticlusters[changepoints[2]]) {
    changepoints <- sample(N, size = 2, replace = FALSE)
  }
  tmp <- anticlusters[changepoints[1]]
  anticlusters[changepoints[1]] <- anticlusters[changepoints[2]]
  anticlusters[changepoints[2]] <- tmp
  return(anticlusters)
}

#' Exchange the anticlusters of two elements in simulated annealing
#'
#' This move incorporates restrictions induced by a preclustering.
#'
#' @param anticlusters The current anticluster affiliation of all
#'     elements
#'
#' @return The anticlustering vector after swapping two elements.
#'
#' @details
#'
#' This function only works as expected when the anticlusters are sorted
#' by precluster, as is the case when it is called from within the
#' `random_move` function above.
#'
#' @noRd
#'

preclustering_move <- function(anticlusters) {
  n_anticlusters <- length(unique(anticlusters))
  n_preclusters <- length(anticlusters) / n_anticlusters
  ## This works because at this point, elements in `anticlusters`
  ## are sorted by precluster
  preclusters <- rep(1:n_preclusters, each = n_anticlusters)
  ## Select a random precluster
  rndclus <- sample(n_preclusters, 1)
  ## Within this precluster, select two random elements that should be
  ## swapped into the respective other anticluster
  changepoints <- sample(n_anticlusters, size = 2, replace = FALSE)
  ## Some ugly code for swapping anticluster affiliation of the two elements
  ## First, ensure that different anticlusters are switched:
  tmp <- anticlusters[preclusters == rndclus][changepoints[1]]
  anticlusters[preclusters == rndclus][changepoints[1]] <-
    anticlusters[preclusters == rndclus][changepoints[2]]
  anticlusters[preclusters == rndclus][changepoints[2]] <- tmp
  return(anticlusters)
}

#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{preclustering_data_format}, contains the features as well
#'     as information on preclustering restrictions (as the first
#'     column, see \code{preclustering_data_format}).
#' @param n_anticlusters How many anticlusters should be created.
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param ignore_preclusters Boolean, should the precluster information
#'     given in the first column of \code{dat} be ignored? If FALSE,
#'     elements from the same precluster are not assigned to the same
#'     anticluster.
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(dat, n_anticlusters, objective,
                            nrep, ignore_preclusters) {
  ## Initialize variables
  n_elements <- nrow(dat)
  n_preclusters <- n_elements / n_anticlusters
  ## Start optimizing
  best_obj <- -Inf
  # only select features so it is not done each iteration
  features <- dat[, -(1:2)]
  for (i in 1:nrep) {
    ## 1. Random sampling without preclustering restrictions
    if (ignore_preclusters == TRUE) {
      anticlusters <- rep(1:n_anticlusters, n_preclusters)
      anticlusters <- sample(anticlusters)
      ## 2. Include preclustering restrictions
    } else if (ignore_preclusters == FALSE) {
      anticlusters <- replicate_sample(n_preclusters, n_anticlusters)
    }
    cur_obj <- get_objective(features, anticlusters, objective)
    if (cur_obj > best_obj) {
      best_assignment <- anticlusters
      best_obj <- cur_obj
    }
  }
  return(best_assignment)
}

#' Replicate a random permutation of \code{1:N} several times
#'
#' @param times How many times should the random sample be generated
#' @param N The function returns several random permutations of
#'     \code{1:N}
#'
#' @return \code{times} random samples of \code{1:N} in a single vector
#'
#' @examples
#' replicate_sample(3, 3)
#'
#' @noRd
replicate_sample <- function(times, N) {
  c(replicate(times, sample(N)))
}

