
#' Heuristic anticlustering using random search methods
#'
#' @param features A data.frame, matrix or vector representing the
#'     features that are used.
#' @param n_anticlusters How many anticlusters should be created.
#' @param preclusters An optional vector representing the preclustering
#'     of the elements in \code{features}
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param distances Alternative data argument that can be used if
#'     \code{features} is not used. A N x N matrix representing the
#'     pairwise dissimilarities between all N elements. Larger values
#'     indicate higher dissimilarity. Can be an object of class
#'     \code{dist} (e.g., returned by \code{\link{dist}} or
#'     \code{\link{as.dist}}.
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

heuristic_anticlustering <- function(features, n_anticlusters,
                                     preclusters = NULL, objective,
                                     nrep, distances) {

  ignore_preclusters <- FALSE
  if (!argument_exists(preclusters)) {
    ignore_preclusters <- TRUE
  }

  ## What was the input: features or distances
  use_distances <- FALSE
  if (argument_exists(features)) {
    input <- features
  } else {
    input <- distances
    use_distances <- TRUE
  }


  ## Bring data into adequate format
  dat <- preclustering_data_format(input, preclusters, n_anticlusters)
  ## Call random sampling subroutine
  best_assignment <- random_sampling(dat, n_anticlusters, objective,
                                     nrep, ignore_preclusters, use_distances)

  ## Return anticluster assignment in original order
  dat[, 1] <- best_assignment
  dat <- sort_by_col(dat, 2)
  anticlusters <- dat[, 1]
  names(anticlusters) <- NULL
  return(anticlusters)
}

#' Bring features into the data format required by preclustering
#' heuristic
#'
#' @param input A matrix representing features or distances.
#' @param preclusters A vector of precluster affiliations. Can be NULL,
#'     see Details.
#'
#' @return An extended data matrix. The first column indicates the
#'     precluster for each element. The matrix is sorted by the
#'     precluster, i.e. by the first column. The second column is a
#'     unique number identifying the original position of each
#'     element. The second column is used in
#'     \code{heuristic_anticlustering} to restore the original order of
#'     the data. The other columns represent the original features that
#'     were passed to this function.
#'
#'  @details
#'
#'  If the argument \code{preclusters} is NULL, no preclustering
#'  constraint was required. This function will still add a column
#'  preclusters, which however will not have an effect on the following
#'  computations: The method \code{random_sampling} will ignore the
#'  precluster column through an
#'  argument \code{ignore_preclusters} that \code{TRUE} whenever the
#'  argument \code{preclusters} is NULL.
#'
#' @noRd
#'

preclustering_data_format <- function(input, preclusters, n_anticlusters) {
  if (!argument_exists(preclusters)) {
    ## This is actually irrelevant numbers and is ignored later on
    preclusters <- rep(1:n_anticlusters, nrow(input) / n_anticlusters)
  }
  dat <- cbind(preclusters, 1:nrow(input), input)
  dat <- sort_by_col(dat, 1) # sort by precluster
  return(dat)
}


#' Random sampling for anticlustering
#'
#' @param dat The data input generated by
#'     \code{preclustering_data_format}, contains features or distances and
#'     information on preclustering restrictions (as the first
#'     column, see \code{preclustering_data_format}).
#' @param n_anticlusters How many anticlusters should be created.
#' @param objective The objective to be maximized, either "distance" or
#'     "variance".
#' @param nrep The number of repetitions tried when assigning elements
#'     to anticlusters when the method is "sampling" or "annealing".
#' @param ignore_preclusters Boolean, should the precluster information
#'     given in the first column of \code{dat} be ignored? If FALSE,
#'     elements from the same precluster are not assigned to the same
#'     anticluster.
#' @param use_distances A boolean flag indicating whether `dat` contains
#'     distances or features. (TRUE = distances were passed)
#'
#' @return A vector representing the anticlustering.
#'
#' @noRd
#'

random_sampling <- function(dat, K, objective, nrep,
                            ignore_preclusters, use_distances) {

  ## Initialize variables
  N <- nrow(dat)
  n_preclusters <- N / K
  ## Start optimizing
  best_obj <- -Inf

  ## Determine how to compute objective, three cases:
  # 1. Distance objective, features were passed
  # 2. Distance objective, distances were passed
  # 3. Variance objective, features were passed
  if (objective == "distance") {
    obj_value <- distance_objective
  } else {
    obj_value <- obj_value_variance
  }

  if (objective == "variance" || use_distances == TRUE) {
    objective_data <- dat[, -(1:2), drop = FALSE]
  } else {
    ## Compute distances from features if distance objective is to be
    ## computed, but features were passed
    objective_data <- as.matrix(dist(dat[, -(1:2), drop = FALSE]))
  }

  for (i in 1:nrep) {
    ## 1. Random sampling without preclustering restrictions
    if (ignore_preclusters == TRUE) {
      anticlusters <- rep(1:K, n_preclusters)
      anticlusters <- sample(anticlusters)
      ## 2. Include preclustering restrictions
    } else if (ignore_preclusters == FALSE) {
      anticlusters <- replicate_sample(n_preclusters, K)
    }
    cur_obj <- obj_value(objective_data, anticlusters)
    if (cur_obj > best_obj) {
      best_assignment <- anticlusters
      best_obj <- cur_obj
    }
  }
  return(best_assignment)
}

#' Replicate a random permutation of \code{1:N} several times
#'
#' @param times How many times should the random sample be generated
#' @param N The function returns several random permutations of
#'     \code{1:N}
#'
#' @return \code{times} random samples of \code{1:N} in a single vector
#'
#' @examples
#' replicate_sample(3, 3)
#'
#' @noRd
replicate_sample <- function(times, N) {
  c(replicate(times, sample(N)))
}

